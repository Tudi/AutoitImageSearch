#include "stdafx.h"
#include "../GameScripts/stdafx.h"

#if defined( _CONSOLE ) && defined(COMPILE_LORDS_SCRIPTS)
void DetectPlayerShields()
{
/*	{
		//try to detect player shields
		TakeScreenshot(0, 0, 1025, 599);
		//		LoadCacheOverScreenshot("Screenshot_0015_1025_0599.bmp", 0, 0);
		LoadCacheOverScreenshot("Screenshot_0025_1025_0599.bmp", 0, 0);
		//KeepGradient(RGB(216, 215, 249), 2.5f);
		KeepColorsMinInRegion(-1, -1, -1, -1, RGB(216, 215, 249));
		SaveScreenshot();
		return;
	}/**/
}
void LocateAndRemoveWaterAndDetectPlayers()
{
/*	{
		//try to remove water zones
		TakeScreenshot(0, 0, 1025, 599);
		LoadCacheOverScreenshot("WaterExamples/Screenshot_0012_1025_0599.bmp", 0, 0);
		GetUniqueColorsInRegion(675, 254, 747, 348);
		SetGradientToColor(0x00A59B63, 0.162f, TRANSPARENT_COLOR);
		//KeepColorsMaxInRegion(-1, -1, -1, -1, RGB(99, 166, 181));
		SaveScreenshot();
		//check if we can still see player labels
		KeepGradient(RGB(33, 106, 148), 0.4f);
		char * tt = ImageSearch_Multiple_PixelCount(0, 50, 33, 21);
		printf("t = %s\n", tt);
		SaveScreenshot();
		return;
	}/**/

	/*	{
	//try to detect player labels
	TakeScreenshot(0, 0, 1282, 722);
	//		LoadCacheOverScreenshot("Screenshot_0015_1025_0599.bmp", 0, 0);
	//		LoadCacheOverScreenshot("Screenshot_0025_1025_0599.bmp", 0, 0);
	//		LoadCacheOverScreenshot("CastleTags1200.bmp", 0, 0);
	TakeScreenshot(0, 0, 1062, 500);
	LoadCacheOverScreenshot("CastleTags_4.bmp", 0, 0);
	//		char * ttt = ImageSearch_Multiple_Gradient(RGB(33, 106, 148), 60, 75, 181 - 151, 235 - 220);
	//remove water if there is any
	SetGradientToColor(0x00A59B63, 0.162f, TRANSPARENT_COLOR);
	SaveScreenshot();
	//remove anything else left than player tags
	KeepGradient(RGB(33, 109, 148), 0.4f);
	SaveScreenshot();
	//		float t = GetPixelRatioInArea(0, 311, 522, 345, 539);
	//		printf("t = %f\n", t);
	//return;
	//		char * tt = ImageSearch_Multiple_PixelCount(0, 75, 181 - 151, 235 - 220); // found less than half shielded
	char * tt = ImageSearch_Multipass_PixelCount(0, 60, 35, 5, 34, 21); // try to find good matches, than try to find worse and worse matches
	printf("t = %s\n", tt);
	SaveScreenshot();
	return;

	PushToColorKeepList(0x406060);
	PushToColorKeepList(0x406080);
	PushToColorKeepList(0x206080);
	PushToColorKeepList(0x204060);
	PushToColorKeepList(0x204040);
	PushToColorKeepList(0x204080);
	PushToColorKeepList(0x206060);
	PushToColorKeepList(0x2060A0);
	PushToColorKeepList(0x004060);
	PushToColorKeepList(0x004080);
	PushToColorKeepList(0x006060);
	PushToColorKeepList(0x006080);
	LoadCacheOverScreenshot("Screenshot_0015_1025_0599.bmp", 0, 0);
	ApplyColorBitmask(0x00E0E0E0);
	//SaveScreenshot();
	//KeepColor3SetBoth(0, 0x00FFFFFF, 0x206080, 0x4080, 0x4060);
	ApplyColorKeepList(0x00FFFFFF, 0);
	SaveScreenshot();

	LoadCacheOverScreenshot("Screenshot_0015_1025_0599.bmp", 0, 0);
	ApplyColorBitmask(0x00C0C0C0);
	//SaveScreenshot();
	KeepColor3SetBoth(0, 0x00FFFFFF, 0x00004080, 0x00004040, 0x00408080);
	//SaveScreenshot();

	LoadCacheOverScreenshot("Screenshot_0015_1025_0599.bmp", 0, 0);
	ApplyColorBitmask(0x00808080);
	//SaveScreenshot();
	KeepColor3SetBoth(0, 0x00FFFFFF, 0x00000080, 0x00008080, 0x00008080);
	//SaveScreenshot();
	}/**/
	{
		//try to detect player labels
		TakeScreenshot(0, 0, 1282, 722);
		LoadCacheOverScreenshot("WaterExamples/Screenshot_0000_1281_0719.bmp", 0, 0);
		//remove water if there is any
		//SetGradientToColor(0x00A59B63, 0.162f, TRANSPARENT_COLOR);
		//SaveScreenshot();
		//remove anything else left than player tags
		//KeepGradient(RGB(33, 109, 148), 0.25f);
		//SaveScreenshot();
		//		float t = GetPixelRatioInArea(0, 311, 522, 345, 539);
		//		printf("t = %f\n", t);
		//return;
		//ApplyColorBitmask(0x00F8F8F8);
		//SaveScreenshot();
		//ApplyColorBitmask(0x00F0F0F0);
		//SaveScreenshot();
		//HistorygramInArea(242,114,282,136);		return;

/*		{
			ApplyColorBitmask(0x00F0F0F0);

			ResetColorKeepList();
			PushToColorKeepList(0x946D21 & 0x00F0F0F0);
			PushToColorKeepList(0x734D10 & 0x00F0F0F0);
			PushToColorKeepList(0x6E4F14 & 0x00F0F0F0);
			PushToColorKeepList(0x704D10 & 0x00F0F0F0);
			PushToColorKeepList(0x6F4D10 & 0x00F0F0F0);
			PushToColorKeepList(0x6E4D10 & 0x00F0F0F0);
			ApplyColorKeepList(0,TRANSPARENT_COLOR);
			ImageSearch_Multipass_PixelCount2(0, 10, 10, 5, 5, 5, 45); // try to find good matches, than try to find worse and worse matches
			SaveScreenshot();
			return;
		}/**/
/*		{
			KeepColorRange(16, 90, 77, 229, 95, 255);
			SaveScreenshot();
			ImageSearch_Multipass_PixelCount2(0, 10, 10, 5, 35, 20, 45); // try to find good matches, than try to find worse and worse matches
			SaveScreenshot();
			return;
		}/**/
/*		{
			//HistorygramInArea(566, 492, 608, 513);
			//HistorygramInArea(242, 114, 282, 136);
			KeepColorRangeAndGradient(RGB(33, 109, 148), 1.0, 16, 255, 77, 255, 95, 255);
			SaveScreenshot();
			ImageSearch_Multipass_PixelCount2(0, 10, 10, 5, 35, 20, 45); // try to find good matches, than try to find worse and worse matches
			SaveScreenshot();
			return;
		}/**/
		{
			KeepGradient3(RGB(33, 109, 148), 0.12f, RGB(16, 77, 113), 0.4f, RGB(40, 116, 155), 0.20f);
			SaveScreenshot();
			//ImageSearch_Multipass_PixelCount2(0, 10, 10, 100, 40, 21, 45); // try to find good matches, than try to find worse and worse matches
			//ImageSearch_Multipass_PixelCount2(0, 10, 10, 100, 20, 11, 45); // try to find good matches, than try to find worse and worse matches
			int rad = 52;
//			ImageSearch_Multipass_PixelCount3(0, 25, 34, 24, rad);
			ImageSearch_Multipass_PixelCount3(0, 85, 5, 8, rad);
//			ImageSearch_Multipass_PixelCount3(0, 60, 8, 12, rad);
//			ImageSearch_Multipass_PixelCount3(0, 40, 9, 13 , rad);
//			ImageSearch_Multipass_PixelCount3(0, 40, 10, 14, rad);
			for (int i = 0; i < SearchResultCount; i++)
			{
				int x = SearchResultXYSAD[i][0];
				int y = SearchResultXYSAD[i][1];
				for (int y1 = y - rad; y1 < y + rad; y1++)
					for (int x1 = x - rad; x1 < x + rad;x1++)
						if (x1 >= 0 && x1<CurScreenshot->GetWidth() && y1 >= 0 && y1<CurScreenshot->GetHeight())
							CurScreenshot->SetPixel(x1, y1, 0x0F00 + i);
			}
			SaveScreenshot();
			printf("res count %d\n", SearchResultCount);
			return;
		}/**/
/*		{
			KeepGradient(RGB(33, 109, 148), 0.14f);
			SaveScreenshot();
			return;
			ImageSearch_Multipass_PixelCount2(BGR(33, 109, 148) & 0x00F8F8F8, 25, 25, 5, 4, 6, 45); // try to find good matches, than try to find worse and worse matches
			for (int i = 0; i < SearchResultCount; i++)
			{
				int x = SearchResultXYSAD[i][0];
				int y = SearchResultXYSAD[i][1];
				CurScreenshot->SetPixel(x, y, 0xFF);
				CurScreenshot->SetPixel(x + 1, y + 1, 0xFF);
				CurScreenshot->SetPixel(x + 1, y, 0xFF);
				CurScreenshot->SetPixel(x, y + 1, 0xFF);
			}
			SaveScreenshot();
			printf("res count %d\n", SearchResultCount);
		}/**/
	}
}

void ExtractPlayerName()
{
/*	{
		char *res;
		//OCR_LoadFontsFromFile("K_C_M_FontMap.txt");
		OCR_LoadFontsFromDir("K_C_M", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_Old1", "K_C_M_");
		OCR_LoadFontsFromDir("K_C_M_old2", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try3", "KCM_");
		TakeScreenshot(0, 0, 1025, 599);
		OCR_SetMaxFontSize(20, 20);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0021_1025_0599.bmp", 0, 0);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0024_1025_0599.bmp", 0, 0);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0042_1025_0599.bmp", 0, 0);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0045_1025_0599.bmp", 0, 0);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0048_1025_0599.bmp", 0, 0);
		//LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0051_1025_0599.bmp", 0, 0);
		//SaveScreenshot();
//		KeepGradientRegion(RGB(239, 222, 65), 0.1f, 446, 182, 680, 205);
//		KeepGradientRegion(RGB(237, 237, 237), 0.015f, 405, 223, 680, 295);
//		KeepGradientRegion(RGB(237, 237, 237), 0.03f, 502, 469, 570, 482);
//		SaveScreenshot();
		//		KeepColorsMinInRegion(446, 182, 680, 205, 144, 133, 41);
		KeepColorsMinInRegion(446, 181, 680, 205, RGB(171, 160, 49));
		//SaveScreenshot();
#if 0==1
		//this was too low, 'ffi' gets merged into 1 char 
		KeepColorsMinInRegion(446, 223, 680, 241, RGB(154, 158, 159));
		KeepColorsMinInRegion(446, 249, 680, 265, RGB(154, 158, 159));
		KeepColorsMinInRegion(405, 276, 680, 295, RGB(154, 158, 159));
		KeepColorsMinInRegion(502, 469, 529, 482, RGB(154, 158, 159));
		KeepColorsMinInRegion(543, 469, 570, 482, RGB(154, 158, 159));
#elif 0==2
		KeepColorsMinInRegion(446, 223, 680, 240, RGB(182, 185, 186)); // might
		KeepColorsMinInRegion(446, 249, 680, 265, RGB(182, 185, 186)); // kills
		KeepColorsMinInRegion(405, 276, 680, 295, RGB(182, 185, 186)); // guild
		KeepColorsMinInRegion(502, 469, 529, 482, RGB(182, 185, 186)); // x
		KeepColorsMinInRegion(543, 469, 570, 482, RGB(182, 185, 186)); // y
#elif 22==22
		KeepColorsMinInRegion(446, 223, 680, 240, RGB(155, 158, 159)); // might
		KeepColorsMinInRegion(446, 249, 680, 265, RGB(155, 158, 159)); // kills
		KeepColorsMinInRegion(405, 276, 680, 295, RGB(155, 158, 159)); // guild
		KeepColorsMinInRegion(502, 469, 529, 482, RGB(155, 158, 159)); // x
		KeepColorsMinInRegion(543, 469, 570, 482, RGB(155, 158, 159)); // y
#elif 0==3
		KeepGradientRegion(RGB(155, 159, 162), 0.04f, 446, 223, 680, 241); // might
		KeepGradientRegion(RGB(155, 159, 162), 0.04f, 446, 249, 680, 266); // kills
		KeepGradientRegion(RGB(155, 159, 162), 0.04f, 405, 276, 680, 295); // guild
		KeepGradientRegion(RGB(155, 159, 162), 0.04f, 502, 469, 529, 482); // x
		KeepGradientRegion(RGB(155, 159, 162), 0.04f, 543, 469, 570, 482); // y
#elif 0==4
		KeepGradientRegionMinValue(RGB(172, 173, 174), 0.02f, 446, 223, 680, 241); // might
		KeepGradientRegionMinValue(RGB(172, 173, 174), 0.02f, 446, 249, 680, 266); // kills
		KeepGradientRegionMinValue(RGB(172, 173, 174), 0.02f, 405, 276, 680, 295); // guild
		KeepGradientRegionMinValue(RGB(172, 173, 174), 0.02f, 502, 469, 529, 482); // x
		KeepGradientRegionMinValue(RGB(172, 173, 174), 0.02f, 543, 469, 570, 482); // y
#elif 0==5
		KeepGradientRegionMinValue(RGB(155, 158, 161), 0.03f, 446, 223, 680, 241); // might
		KeepGradientRegionMinValue(RGB(155, 158, 161), 0.03f, 446, 249, 680, 266); // kills
		KeepGradientRegionMinValue(RGB(155, 158, 161), 0.03f, 405, 276, 680, 295); // guild
		KeepGradientRegionMinValue(RGB(155, 158, 161), 0.03f, 502, 469, 529, 482); // x
		KeepGradientRegionMinValue(RGB(155, 158, 161), 0.03f, 543, 469, 570, 482); // y
#elif 0==6
		RemoveIfHasStrongerNeighbours(3, 446, 223, 680, 241); // might
		RemoveIfHasStrongerNeighbours(3, 446, 249, 680, 266); // kills
		RemoveIfHasStrongerNeighbours(3, 405, 276, 680, 295); // guild
		RemoveIfHasStrongerNeighbours(3, 502, 469, 529, 482); // x
		RemoveIfHasStrongerNeighbours(3, 543, 469, 570, 482); // y
#elif 0==7
		ApplyColorBitmask(0x00F0F0F0);
		ErodeNotInLine(446, 223, 680, 241); // might
		ErodeNotInLine(446, 249, 680, 266); // kills
		ErodeNotInLine(405, 276, 680, 295); // guild
		ErodeNotInLine(502, 469, 529, 482); // x
		ErodeNotInLine(543, 469, 570, 482); // y
#elif 0==8
		// fonts fade out to black. We want to remove pixel that is close to black, but a pixel that would not break a line inside the font
		// remove non font color. Leave some very wide fonts
		// keep eroding them without breaking lines
		ErodeOnEdgeNeighbours(446, 223, 680, 241); // might
		ErodeOnEdgeNeighbours(446, 249, 680, 266); // kills
		ErodeOnEdgeNeighbours(405, 276, 680, 295); // guild
		ErodeOnEdgeNeighbours(502, 469, 529, 482); // x
		ErodeOnEdgeNeighbours(543, 469, 570, 482); // y
#endif
		//SaveScreenshot();
		//return;
		//ConvertToGrayScale();
		//DecreaseColorCount(1);
		//SaveScreenshot();
		//SaveScreenshot();
		//GetUniqueColorsInRegion(502, 223, 580, 237);
		//KeepColorSetRest(0x00000000, 0x00FFFFFF, 0x00000000);
		//SaveScreenshot();
		//ErrodeRegionToTransparent();
		//SaveScreenshot();
		//read name
		res = OCR_ReadTextLeftToRightSaveUnknownChars(446, 181, 680, 205);
		if (res != NULL)
		{
		printf("Name : %s\n", res);
		}
		//read might
		res = OCR_ReadTextLeftToRightSaveUnknownChars(502, 223, 680, 241);
		if (res != NULL)
		{
		printf("might : %s\n", res);
		RemoveCharFromNumberString(res, ',');
		printf("might : %s\n", res);
		}
		//read troops killed
		res = OCR_ReadTextLeftToRightSaveUnknownChars(554, 249, 680, 265);
		if (res != NULL)
		{
		printf("kills : %s\n", res);
		RemoveCharFromNumberString(res, ',');
		printf("kills : %s\n", res);
		}
		//read guild
		res = OCR_ReadTextLeftToRightSaveUnknownChars(405, 276, 680, 295);
		if (res != NULL)
		{
		printf("guild : %s\n", res);
		}
		//read location X
		res = OCR_ReadTextLeftToRightSaveUnknownChars(502, 469, 529, 482);
		if (res != NULL)
		{
		printf("x : %s\n", res);
		}
		//read location y
		res = OCR_ReadTextLeftToRightSaveUnknownChars(543, 469, 570, 482);
		if (res != NULL)
		{
		printf("y : %s\n", res);
		}
		return;
	}/**/

/*	{
		char *res;
		//OCR_LoadFontsFromFile("K_C_M_FontMap.txt");
		OCR_LoadFontsFromDir("K_C_M", "KCM_");
		TakeScreenshot(0, 0, 1025, 599);
		OCR_SetMaxFontSize(20, 20);
//		LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0036_0280_0325.bmp", 0, 0);
		LoadCacheOverScreenshot("CastlepopupExamples/Screenshot_0034_0280_0325.bmp", 0, 0);
		//read name
		res = OCR_ReadTextLeftToRightSaveUnknownChars(446 - 400, 182 - 165, 680 - 400, 205 - 165);
		printf("Name : %s\n", res);
		//read might
		res = OCR_ReadTextLeftToRightSaveUnknownChars(502 - 400, 223 - 165, 680 - 400, 240 - 165);
		printf("might : %s\n", res);
		RemoveCharFromNumberString(res, ',');
		printf("might : %s\n", res);
		//read troops killed
		res = OCR_ReadTextLeftToRightSaveUnknownChars(554 - 400, 249 - 165, 680 - 400, 265 - 165);
		printf("kills : %s\n", res);
		RemoveCharFromNumberString(res, ',');
		printf("kills : %s\n", res);
		//read guild
		res = OCR_ReadTextLeftToRightSaveUnknownChars(405 - 400, 276 - 165, 680 - 400, 295 - 165);
		printf("guild : %s\n", res);
		//read location X
		res = OCR_ReadTextLeftToRightSaveUnknownChars(502 - 400, 469 - 165, 529 - 400, 482 - 165);
		printf("x : %s\n", res);
		//read location y
		res = OCR_ReadTextLeftToRightSaveUnknownChars(543 - 400, 469 - 165, 570 - 400, 482 - 165);
		printf("y : %s\n", res);
	}/**/
/*	{
		char *res;
		TakeScreenshot(0, 0, 700, 700);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "OCRLowresInput";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 0;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
//					if ((Index & 1) == 0)
//						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					//continue;
					//SaveScreenshot();
					//KeepColorsMinInRegion(446 - 400, 181 - 165, 680 - 400, 205 - 165, RGB(171, 160, 49));
					KeepColorsMinInRegion(369, 183, 650, 405, RGB(150, 151, 154));

					//SaveScreenshot();
					//continue;
					//res = OCR_ReadTextLeftToRightSaveUnknownChars(446 - 400, 181 - 165, 680 - 400, 205 - 165);
					//printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(406, 235, 630, 251);
					printf("%s\n", res);
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/
/*	{
		char *res;
		TakeScreenshot(0, 0, 1910, 1100);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "OCRHighResInput";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 0;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					//					if ((Index & 1) == 0)
					//						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					//continue;
					//SaveScreenshot();
					//KeepColorsMinInRegion(446 - 400, 181 - 165, 680 - 400, 205 - 165, RGB(171, 160, 49));
					KeepColorsMinInRegion(645, 355, 1195, 810, RGB(201, 201, 203));

					//SaveScreenshot();
					//continue;
					//res = OCR_ReadTextLeftToRightSaveUnknownChars(446 - 400, 181 - 165, 680 - 400, 205 - 165);
					//printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(722, 461, 1190, 490);
					printf("%s\n", res);
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/
	{
		char *res;
		OCR_SetActiveFontSet(2, "K_C_M_Playernames/");
		OCR_LoadFontsFromDir("K_C_M_Playernames", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_Playernames2", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_Playernames3", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_Playernames_wide", "KCM_");
		TakeScreenshot(0, 0, 401, 381);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "h:/Lords/CastlepopupExamples7";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 2000 * 4;
		int BatchProcessMaxCount = SkipFirstN + 2000;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					//printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					KeepColorsMinInRegion(121, 16, 399, 44, RGB(194, 180, 55));
					//KeepColorsMinInRegion(121, 16, 390, 44, RGB(178, 165, 50));
					//SaveScreenshot();
					res = OCR_ReadTextLeftToRightSaveUnknownChars(121, 16, 399, 44);
					printf("%s\n", res);
					if (OCR_FoundNewFont > 0)
					{
						printf("Original Filename was %s\n", FullPath);
						SaveScreenshot();
					}
					UnloadLastCache();
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/
}

void ExtractKillsMight()
{
	{
		char *res;
		OCR_SetActiveFontSet(4, "K_C_M_MightKills/");
		OCR_LoadFontsFromDir("K_C_M_MightKills", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_MightKills2", "KCM_");
		TakeScreenshot(0, 0, 401, 381);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "h:/Lords/CastlepopupExamples7";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 2900 * 0;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//continue;
					//SaveScreenshot();
					KeepColorsMinInRegion(193, 66, 350, 88, RGB(211, 211, 211));
					KeepColorsMinInRegion(258, 97, 390, 119, RGB(211, 211, 211));
					//SaveScreenshot();
					//continue;
					int tOCR_FoundNewFont = 0;
					res = OCR_ReadTextLeftToRightSaveUnknownChars(193, 66, 350, 88);
					tOCR_FoundNewFont += OCR_FoundNewFont;
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(258, 97, 390, 119);
					tOCR_FoundNewFont += OCR_FoundNewFont;
					printf("%s\n", res);
					if (tOCR_FoundNewFont > 0)
						SaveScreenshot();
					UnloadLastCache();
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/
}

void ExtractXY()
{
	{
		char *res;
		OCR_SetActiveFontSet(3, "K_C_M_xy/");
		OCR_LoadFontsFromDir("K_C_M_xy", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_xy2", "KCM_");
		TakeScreenshot(0, 0, 401, 381);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "h:/Lords/CastlepopupExamples7";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 2900 * 3;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					KeepColorsMinInRegion(129, 363, 268, 379, RGB(166, 172, 175));
					//SaveScreenshot();
					res = OCR_ReadTextLeftToRightSaveUnknownChars(129, 363, 268, 379);
					printf("%s\n", res);
					if (OCR_FoundNewFont == 1)
						SaveScreenshot();
					UnloadLastCache();
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}
		//SaveScreenshot();
		return;
	}/**/
}

void ExtractVIP()
{
	{
		char *res;
		OCR_SetActiveFontSet(3, "K_C_M_VIP/");
		OCR_LoadFontsFromDir("K_C_M_VIP", "KCM_");
//		OCR_LoadFontsFromDir("K_C_M_xy2", "KCM_");
		TakeScreenshot(0, 0, 401, 381);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "h:/Lords/CastlepopupExamples5";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 2900 * 2;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					//KeepColorsMinInRegion(66, 17, 90, 36, RGB(214, 199, 128));
					KeepColorsMinInRegion(66, 17, 90, 36, RGB(189, 174, 102));
					//SaveScreenshot();
					//break;
					res = OCR_ReadTextLeftToRightSaveUnknownChars(66, 17, 90, 36);
					printf("%s\n", res);
					if (OCR_FoundNewFont == 1)
						SaveScreenshot();
					UnloadLastCache();
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}
		//SaveScreenshot();
		return;
	}/**/
}

void ExtractGuild()
{
/*	{
		char *res;
		OCR_LoadFontsFromDir("K_C_M", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_Old1", "K_C_M_");
		OCR_LoadFontsFromDir("K_C_M_old2", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try3", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try4", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try5", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try6", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_try7", "KCM_");
		TakeScreenshot(0, 0, 300, 350);
		OCR_SetMaxFontSize(20, 20);
		ResetColorKeepList();
		PushToColorKeepList(RGB(176, 179, 181));
		//PushToColorKeepList(RGB(173, 175, 176));
		//PushToColorKeepList(RGB(173, 176, 176));
		PushToColorKeepList(RGB(171, 174, 176));
		PushToColorKeepList(RGB(170, 175, 177));
		PushToColorKeepList(RGB(170, 174, 177));
		PushToColorKeepList(RGB(167, 170, 172));
		std::string path = "CastlepopupExamples2";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 0;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					if ( ( Index & 1 ) == 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
					//SaveScreenshot();
					//continue;
					//SaveScreenshot();
					KeepColorsMinInRegion(446 - 400, 181 - 165, 680 - 400, 205 - 165, RGB(171, 160, 49));
					//KeepColorsMinInRegion(446 - 400, 181 - 165, 680 - 400, 205 - 165, RGB(182, 170, 53));
					KeepColorsMinInRegion(500 - 400, 223 - 165, 680 - 400, 240 - 165, 0xA09E9A); // might
					KeepColorsMinInRegion(446 - 400, 249 - 165, 680 - 400, 265 - 165, 0xA09E9A); // kills
					ApplyColorEliminateListToArea(0, 405 - 400, 276 - 165, 680 - 400, 295 - 165);
					KeepColorsMinInRegion(405 - 400, 276 - 165, 680 - 400, 295 - 165, 0xA09E9A); // guild
					//ApplyColorEliminateListToArea(0, 502 - 400, 469 - 165, 529 - 400, 482 - 165);
					KeepColorsMinInRegion(502 - 400, 469 - 165, 529 - 400, 482 - 165, 0xA09E9A); // x
					KeepColorsMinInRegion(543 - 400, 469 - 165, 570 - 400, 482 - 165, 0xA09E9A); // y
			//SaveScreenshot();
			//continue;
					res = OCR_ReadTextLeftToRightSaveUnknownChars(446 - 400, 181 - 165, 680 - 400, 205 - 165);
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(500 - 400, 223 - 165, 680 - 400, 240 - 165);
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(554 - 400, 249 - 165, 680 - 400, 265 - 165);
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(405 - 400, 276 - 165, 680 - 400, 295 - 165);
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(502 - 400, 469 - 165, 529 - 400, 482 - 165);
					printf("%s\n", res);
					res = OCR_ReadTextLeftToRightSaveUnknownChars(543 - 400, 469 - 165, 570 - 400, 482 - 165);
					printf("%s\n", res);
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0 );
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/

	{
		char *res;
		OCR_SetActiveFontSet(1, "K_C_M_guild/");
		OCR_LoadFontsFromDir("K_C_M_guild", "KCM_");
		OCR_LoadFontsFromDir("K_C_M_guild2", "KCM_");
		TakeScreenshot(0, 0, 401, 381);
		OCR_SetMaxFontSize(20, 20);
		std::string path = "h:/Lords/CastlepopupExamples7";
		std::string search_path = path;
		search_path += "/*.*";
		std::string SkipUntilFile = "";
		int FoundFirstFile = SkipUntilFile.length() == 0;
		int SkipFirstN = 2900 * 4;
		int BatchProcessMaxCount = SkipFirstN + 2900;
		int Index = 0;
		WIN32_FIND_DATA fd;
		HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do {
				// read all (real) files in current folder
				// , delete '!' read other 2 default folder . and ..
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					Index++;
					if (FoundFirstFile == 0)
					{
						if (strcmp(fd.cFileName, SkipUntilFile.c_str()) == 0)
							FoundFirstFile = 1;
						else
							continue;
					}
					BatchProcessMaxCount--;
					if (SkipFirstN-- > 0)
						continue;
					char FullPath[2500];
					sprintf_s(FullPath, sizeof(FullPath), "%s/%s", path.c_str(), fd.cFileName);
					printf("%d)Parsing file : %s\n", Index, FullPath);
					LoadCacheOverScreenshot(FullPath, 0, 0);
//					LoadCacheOverScreenshot("CastlepopupExamples6/Screenshot_5230_0400_0380.bmp", 0, 0);
					//SaveScreenshot();
					KeepColorsMinInRegion(73, 131, 370, 154, RGB(173, 174, 176));
					//SaveScreenshot();
					res = OCR_ReadTextLeftToRightSaveUnknownChars(73, 131, 370, 154);
					printf("%s\n", res);
					if (OCR_FoundNewFont > 0)
					{
						printf("Original Filename was %s\n", FullPath);
						SaveScreenshot();
					}
					UnloadLastCache();
				}
			} while (::FindNextFile(hFind, &fd) && BatchProcessMaxCount > 0);
			::FindClose(hFind);
		}

		//SaveScreenshot();
		return;
	}/**/
}

void RunLordsTesting()
{
	int Start = GetTimeTickI();
	//ExtractXY();
	//ExtractKillsMight();
	//ExtractPlayerName();
	//ExtractGuild();
	{
		LocateAndRemoveWaterAndDetectPlayers();
		return;
	}
	ExtractVIP();
	int End = GetTimeTickI();

	// always check if what we do is the right way to do it
	if (OCR_Statistics_TotalCompares > 0)
	{
		printf("OCR statistics - Total compares : %d\n", OCR_Statistics_TotalCompares);
		printf("OCR statistics - Pixel hash skips : %d -> pass rate %d\n", OCR_Statistics_HashEliminations, OCR_Statistics_HashEliminations * 100 / OCR_Statistics_TotalCompares);
		printf("OCR statistics - Pixel count skips : %d -> pass rate %d\n", OCR_Statistics_PixelCountEliminations, OCR_Statistics_PixelCountEliminations * 100 / OCR_Statistics_TotalCompares);
		printf("OCR statistics - Size Skips : %d -> pass rate %d\n", OCR_Statistics_SizeEliminations, OCR_Statistics_SizeEliminations * 100 / OCR_Statistics_TotalCompares);
		printf("OCR statistics - Pixel matches skips : %d -> pass rate %d\n", OCR_Statistics_PixelCountMatchEliminations, OCR_Statistics_PixelCountMatchEliminations * 100 / OCR_Statistics_TotalCompares);
		printf("OCR statistics - Real matches : %d\n", OCR_Statistics_RealMatch);
		printf("OCR statistics - Pixel compares : %d M\n", int(OCR_Statistics_PixelsCompared / 1000000));
		printf("OCR statistics - Similar compares : %d\n", OCR_Statistics_SimilarSearches);
		printf("OCR statistics - Time spent : %d\n", End - Start);
	}
}
#endif